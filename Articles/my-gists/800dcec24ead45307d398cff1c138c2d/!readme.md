# AtCoder 
- https://github.com/atcoder/ac-library
- https://atcoder.jp/contests/practice2

- **Bit全探索**
  - **説明:** Bit全探索は、要素の組み合わせをすべて試すアルゴリズムです。N個の要素がある場合、2^N通りの組み合わせを生成できます。
  - **参考URL:** [Bitmasking and Dynamic Programming](https://www.topcoder.com/thrive/articles/Bit%20Manipulation)

- **累積和**
  - **説明:** 累積和は、配列内の要素の部分和を高速に計算するための手法です。
  - **参考URL:** [Cumulative Sum (Prefix Sum)](https://cp-algorithms.com/data_structures/segment_tree.html)

- **二分探索**
  - **説明:** 二分探索は、ソートされたリスト内で特定の要素を効率的に検索するアルゴリズムです。
  - **参考URL:** [Binary Search](https://www.geeksforgeeks.org/binary-search/)

- **尺取り法**
  - **説明:** 尺取り法は、連続する区間を調査するアルゴリズムで、特に部分和の問題に適しています。
  - **参考URL:** [Explanation of the Two-Pointers Technique](https://qiita.com/drken/items/ecd1a472d3a0e7db8dce)

- **基本的なDP（動的計画法）**
  - **説明:** 動的計画法は、最適化問題を効率的に解くためのアルゴリズムです。部分和、ナップザック、LCS（最長共通部分列）、区間DP、bitDPなど、さまざまな問題に応用できます。
  - **参考URL:** [Dynamic Programming - GeeksforGeeks](https://www.geeksforgeeks.org/dynamic-programming/)

- **DFS（深さ優先探索）とBFS（幅優先探索）**
  - **説明:** DFSとBFSは、グラフ探索アルゴリズムです。DFSはスタックを使用し、BFSはキューを使用して、グラフ内のノードを探索します。
  - **参考URL:** [Depth-First Search (DFS) - GeeksforGeeks](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)

- **O(N^1/2) の素数系諸々**
  - **説明:** O(N^1/2) の素数判定アルゴリズムは、与えられた数が素数かどうかを判定するための効率的な方法です。エラトステネスのふるいなどがあります。
  - **参考URL:** [Sieve of Eratosthenes - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E3%81%B5%E3%82%8B%E3%81%84)

- **modをとるnCr、繰り返し2乗法**
  - **説明:** modを取るnCr（組み合わせ）を計算するためのアルゴリズムとして、フェルマーの小定理や逆元を使用します。繰り返し2乗法は、指数を高速に計算するための手法です。
  - **参考URL:** [モジュラ逆元と組み合わせ論](https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a)

- **Grundy数**
  - **説明:** Grundy数は、ゲーム理論のアルゴリズムで、ゲームの局面の価値を表します。これを使用して、ゲームの最適な戦略を見つけることができます。
  - **参考URL:** [Grundy数 - Wikipedia](https://ja.wikipedia.org/wiki/Grundy%E6%95%B0)
